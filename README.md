# Tree Sense — Shortest Path

An interactive FastAPI-based tool to compute shortest/low-cost paths on aerial or ground images using configurable A* search. Upload an image, mark start/goal, and get back a summary image plus an animation of the search process.

This README documents the project purpose, how it works, the algorithms used, where outputs are stored, how to run the service, and ideas for future improvements.

## Key features

- Upload PNG/JPG images via a small web UI.
- Interactive point selection for start / goal / waypoints / obstacles.
- Converts image to a traversable grid using a dark-pixel threshold (plus manual obstacle overrides).
- Configurable A* search with 4- or 8-neighbor moves and Manhattan or Euclidean heuristic.
- Produces a static summary figure and an animation (MP4/WebM) of the search.
- Stores per-image artifacts under `data/<image_id>/` and returns URLs for download.

## Example outputs

Summary visualization (generated by the pipeline):

![Best path summary](BestPath-JungleMode/5552d8c90d5a/image/best_path_summary.png)

Base/original image used for the example:

![Original image](BestPath-JungleMode/5552d8c90d5a/image/base.png)

Search animation sample (MP4):

<video controls width="720" preload="metadata" autoplay loop muted>
  <source src="BestPath-JungleMode/5552d8c90d5a/video/search_animation.mp4" type="video/mp4">
  Your browser does not support the video tag. You can download the animation at BestPath-JungleMode/5552d8c90d5a/video/search_animation.mp4
</video>

## Quickstart

1. Create a virtual environment and install dependencies:

```powershell
python -m venv .venv
.\.venv\Scripts\Activate.ps1   # PowerShell on Windows
pip install -r requirements.txt
```

2. Launch the API for development (auto-reload):

```powershell
uvicorn main:app --reload
```

3. Open `http://127.0.0.1:8000/` in your browser, upload an image, pick points and run the solver. Alternatively, call the `/solve` endpoint with JSON (see below).

Note: MP4 generation needs `ffmpeg`. If no system `ffmpeg` is available, the app uses the bundled binary provided by `imageio-ffmpeg`.

## API Endpoints (summary)

- `GET /` — Upload form/UI.
- `POST /upload` — Accepts an image file (multipart/form-data). Redirects to `/select/{image_id}`.
- `GET /select/{image_id}` — Interactive point-selection UI.
- `POST /solve` — Trigger the solver (form submissions or JSON payloads supported).
- `GET /result/{image_id}` — Result page showing the summary and animation.
- `GET /result/{image_id}/summary.png` — Download the static Matplotlib summary.
- `GET /result/{image_id}/animation` — Download the animation (MP4 or WebM).

## JSON Solve Payload

Send a `POST /solve` with `Content-Type: application/json` to run programmatically. Example payload:

```json
{
  "image_id": "<returned-from-upload>",
  "start": [120, 340],
  "goal": [760, 120],
  "waypoints": [[300, 280]],
  "obstacles": [[420, 260]],
  "dark_threshold": 80,
  "neighbor_mode": "8",
  "heuristic": "euclidean"
}
```

Response (successful): JSON with the ordered path, explored nodes, any nudges/adjustments, and URLs to the generated `summary.png` and `animation`.

## How the pipeline works (implementation details)

This section explains the core processing steps and algorithms used so the implementation is clear for future development.

1. Image ingestion

   - The uploaded image is saved in a per-image directory (e.g. `data/<image_id>/original.png`).
   - A copy is scaled or padded if needed so the grid resolution is manageable (configurable in the code).

2. Grid and cost map generation

   - Convert the image to grayscale and compute a per-pixel intensity.
   - Apply a `dark_threshold` — pixels darker than this threshold are treated as obstacles by default.
   - Optional manual obstacle pixels (from the UI or JSON payload) are applied on top of the threshold map.
   - A cost map is produced where free pixels have low traversal cost and blocked pixels have an extremely high cost (or are marked non-traversable). You can optionally apply small morphological smoothing to remove speckle noise.
   - (Optional) The codebase contains hooks to weight costs by color features (for example, increased cost for greener pixels if you want to avoid dense vegetation), but the default behavior is binary obstacle vs free + equal unit cost for free cells.

3. Nudge start/goal/waypoints

   - If any selected point lies on a blocked pixel, the solver searches outward (breadth-first) to find the closest free pixel and records the adjustment in metadata.

4. Search: A* implementation

   - A* search is used to find the lowest cost path from start to goal while optionally respecting waypoints.
   - Moves: 4- or 8-neighbor connectivity is supported.
   - Move cost: cardinal moves cost 1.0; diagonal moves cost sqrt(2) when using 8-neighbor mode.
   - Cell cost: the local traversal cost from the cost map is added to the move cost so the total edge cost is move_cost + cell_cost.
   - Heuristics: Manhattan (L1) or Euclidean (L2) are selectable. Heuristics are admissible for the chosen move model.

5. Recording explored nodes and frames

   - During search we record the order of node expansions (for visualization) and optionally capture frames to produce an animation. The summary figure overlays the final path and explored nodes onto the original image.
   - Animation generation: Matplotlib frames are collected and then encoded into MP4 (preferred) or WebM using `imageio` + `imageio-ffmpeg`.

6. Outputs

   - `data/<image_id>/summary.png` — A multi-panel Matplotlib figure showing original image, cost map, best-path overlay and explored vs best path.
   - `data/<image_id>/animation.mp4` (or .webm) — Search animation.
   - `data/<image_id>/metadata.json` — Search metadata (original coordinates, any nudges, algorithm parameters, runtime stats).

## Algorithms and complexity

- Image processing: O(N_pixels) for threshold and cost map generation.
- A* search: worst-case O(N_nodes log N_nodes) due to the priority queue; typical performance depends on obstacle density and heuristic quality.
- Memory: stores closed/open sets and optionally per-frame images for animation. For large images you can downscale before search to reduce CPU/time.

Edge cases handled

- Start or goal on an obstacle — the solver nudges to the nearest free pixel and reports the adjustment.
- No path found — the API returns an informative message and still produces a visualization showing explored area.
- Small speckle obstacles — optional morphological smoothing can reduce pathological search behavior caused by noisy pixels.

## Development notes & project status

- MVP: Upload, interactive selection, A* solver (4/8 neighbors), summary + animation generation — implemented and working.
- Storage: Per-image artifacts under `data/<image_id>/`.
- Testing: Contains integration style manual tests via the UI. Unit tests are currently light; adding automated tests is listed in future work.

Quality gates (quick checklist)

- Build: Python + pip requirements (see `requirements.txt`).
- Runtime: `uvicorn main:app --reload` to run locally.
- Video: `ffmpeg` recommended; if not present the app uses `imageio-ffmpeg`.

## Requirements

- Python 3.8+ (3.11 recommended)
- See `requirements.txt` for Python packages. Typical packages include: `fastapi`, `uvicorn`, `numpy`, `scipy`, `matplotlib`, `imageio`, `imageio-ffmpeg`, `Pillow`.

## Where artifacts are saved

- `data/<image_id>/original.png` — uploaded image
- `data/<image_id>/summary.png` — static figure
- `data/<image_id>/animation.mp4` — animation
- `data/<image_id>/metadata.json` — parameter and runtime metadata

## Future work (ideas and roadmap)

1. Weighted-cost maps: automatically compute vegetation or slope costs from color and/or elevation data (if available) so paths prefer safer/clearer terrain instead of strictly shortest.
2. Multi-scale search: run coarse A* on a downsampled image to get candidate corridor, then refine locally to save time on large images.
3. Parallel / GPU acceleration: use numba/cupy or C++ bindings for faster frontier expansions for very large inputs.
4. Add unit tests and CI pipeline, including small sample images to validate behavior.
5. Dockerfile and deployment manifest so the app can be run in containers with a pinned ffmpeg runtime.
6. Authentication & rate-limiting for a public API and quotas for long-running searches.
7. Multi-agent routing (multiple paths with conflict avoidance) and path smoothing.

## Getting help / contributing

If you'd like to contribute, open an issue or a pull request. Good first issues: add unit tests for the A* implementation, add CLI utilities for batch processing, and add a Dockerfile.

---

If you'd like, I can (next):

 - add a minimal `Dockerfile` for local runs, or
 - add a small unit test that validates A* on a synthetic obstacle map, or
 - generate a short developer guide showing where to change the cost function.

Tell me which you'd like and I'll continue.
